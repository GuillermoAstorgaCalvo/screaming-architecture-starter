---
description: 'Routing principles, structure, and composition across domains'
globs: ['**/*']
alwaysApply: false
---

## Routing

### Principles

- Centralized route definitions in `app/router.tsx`.
- Prefer `React.lazy` + `Suspense` for page-level lazy loading. For very large domains,
  consider additional submodule-level splitting (e.g., widgets/sections) to keep bundles small.
- Keep route params typed via shared `types/*` when needed.
- Use path aliases for imports; avoid re-export barrels when composing routes.
- Pages wrapped with `AppLayout` for consistent layout structure.
- Use `withTheme` HOC to inject theme props into pages when needed.

### Structure

- Global route constants in `core/config/routes.ts` (e.g., `ROUTES.HOME`).
- Route-level layouts in `shared/components/layout/*` (e.g., `Layout`, `Navbar`).
- App-level layout wrapper in `app/components/AppLayout.tsx`.
- Error boundaries wrap the router in `app/App.tsx`.

### Current Implementation Pattern

```tsx
// app/router.tsx (actual implementation)
import AppLayout from '@app/components/AppLayout';
import { withTheme } from '@app/components/PageWrapper';
import Error404 from '@app/pages/Error404';
import type { AnalyticsPageView } from '@core/ports/AnalyticsPort';
import { useAnalytics } from '@core/providers/analytics/useAnalytics';
import { buildRoute } from '@core/router/routes.gen';
import { DefaultLoadingFallback } from '@core/ui/utilities/loadable/components/loadableFallback';
import { RouteTransition } from '@core/ui/utilities/motion/components/RouteTransition';
import { lazy, Suspense, useEffect } from 'react';
import { Route, Routes, useLocation } from 'react-router-dom';

const LandingPageBase = lazy(() => import('@domains/landing/pages/LandingPage'));
const LandingPage = withTheme(LandingPageBase);

export default function Router() {
	const analytics = useAnalytics();
	const location = useLocation();

	useEffect(() => {
		const path = `${location.pathname}${location.search}${location.hash}`;
		const pageView: AnalyticsPageView = { path };
		const documentTitle = 'document' in globalThis ? globalThis.document.title : undefined;
		if (documentTitle !== undefined) {
			pageView.title = documentTitle;
		}
		const windowLocation = 'window' in globalThis ? globalThis.window.location.href : undefined;
		if (windowLocation !== undefined) {
			pageView.location = windowLocation;
		}
		analytics.trackPageView(pageView);
	}, [analytics, location.hash, location.pathname, location.search]);

	return (
		<AppLayout>
			<Suspense fallback={<DefaultLoadingFallback />}>
				<RouteTransition locationKey={location.pathname}>
					<Routes location={location}>
						<Route path={buildRoute('HOME')} element={<LandingPage />} />
						<Route path="*" element={<Error404 />} />
					</Routes>
				</RouteTransition>
			</Suspense>
		</AppLayout>
	);
}
```

**Key Implementation Details:**

- Uses `buildRoute()` from `@core/router/routes.gen` for type-safe route building
- Wraps routes with `RouteTransition` for route change animations
- Uses `DefaultLoadingFallback` from `@core/ui/utilities/loadable/components/loadableFallback` for consistent loading states
- Tracks page views via `useAnalytics` hook on route changes
- Uses `useLocation` hook for route transition key and analytics tracking
- Pages are wrapped with `withTheme` HOC to inject theme props
- All routes are wrapped in `AppLayout` for consistent layout structure

### Route Protection

For protected routes, use the `ProtectedRoute` component from `@app/components/ProtectedRoute`:

```tsx
import { ProtectedRoute } from '@app/components/ProtectedRoute';
import { authenticatedGuard, createPermissionGuard } from '@core/router/routes.guards';

<Route
	path={buildRoute('PROTECTED')}
	element={
		<ProtectedRoute
			guards={[authenticatedGuard, createPermissionGuard(['user:read'], { requireAll: true })]}
		>
			<ProtectedPage />
		</ProtectedRoute>
	}
/>;
```

### Route Building

Always use `buildRoute()` from `@core/router/routes.gen` instead of string literals:

```tsx
// ✅ Good
<Route path={buildRoute('HOME')} element={<HomePage />} />

// ❌ Bad
<Route path="/" element={<HomePage />} />
```

The `buildRoute()` function provides type safety and ensures route paths are centralized in `core/config/routes.ts`.

### Future Pattern (Domain Route Aggregation)

For larger applications, domains can expose route arrays:

1. Domain exposes `routes` array with lazy pages in `domains/<domain>/routes.ts`.
2. App router imports domain `routes` and composes.
3. Nested routes allowed per domain.
